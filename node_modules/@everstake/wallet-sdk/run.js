
const { Solana }  = require("./index.js");
const { address, createKeyPairSignerFromBytes, getBase58Encoder, getBase58Decoder, createSolanaRpc, mainnet, compileTransaction, sendAndConfirmTransactionFactory, getSignatureFromTransaction } = require('@solana/web3.js');

const { getU8Encoder, getU32Encoder } = require('@solana/web3.js');

const start = async function() {
//     console.log('Encode: ', getU8Encoder().encode(0));
//     console.log('Encode: ', getU32Encoder().encode(2));
// return;
    // let sol = new Solana('mainnet-beta');
    // const rpc = createSolanaRpc('https://api.mainnet-beta.solana.com');
    

    let sol = new Solana('devnet');
    const rpc = createSolanaRpc('https://explorer-api.devnet.solana.com');
    const destinationAddress = address('2epyttTop1iHCc1h2GnkTbcLEBDjehwfyb2P8UYsH7Y2');
    // const destinationAddress = address('4rTehNfiKJNrj9nUD2hQ4KNSEgDXKtwinY3E1yPrdq6E');
    
    

    // let del = await sol.getDelegations(destinationAddress);
    let del = await sol.getDelegations(destinationAddress);
    console.log(del);

    let tx = await sol.unstake(destinationAddress, 10000000n, '0');

    // return;
    const secretKey = "";
    const sourceKeypair = await createKeyPairSignerFromBytes(
        getBase58Encoder().encode(secretKey)
    );
    console.log('Address: ', sourceKeypair.address);
    
    // let tx = await sol.stake(destinationAddress, 10000000n, '0');

    // let tx = await sol.stake(destinationAddress, 10000000, null);
    // console.log(`Address: `, tx.result.stakeAccount);
    // return;

    // let transaction = compileTransaction(tx.result.transaction);
    let transaction = compileTransaction(tx.result.unstakeTx);
    const [signatureDictionary] = await sourceKeypair.signTransactions([transaction]);

    const signature = signatureDictionary[sourceKeypair.address];
    console.log(
        { signature: signature ? getBase58Decoder().decode(signature) : null },
        '>>  Signing a transfer SOL transaction',
    );

    transaction = addSignature(transaction, destinationAddress, signature);

    // transaction.signatures = signature;
// const rpcSubscriptions = createSolanaRpcSubscriptions('ws://127.0.0.1:8900');

/**
 * SETUP: TRANSACTION SENDER
 * We use the RPC connection that you just created to build a reusable transaction sender.
 */
const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({
    /**
     * The RPC implements a `sendTransaction` method which relays transactions to the network.
     */
    rpc,
    /**
     * RPC subscriptions allow the transaction sender to subscribe to the status of our transaction.
     * The sender will resolve when the transaction is reported to have been confirmed, or will
     * reject in the event of an error, or a timeout if the transaction lifetime is thought to have
     * expired.
     */
    // rpcSubscriptions,
});

console.log(
    '[step 3] Sending transaction: https://explorer.solana.com/tx/%s?cluster=custom&customUrl=127.0.0.1:8899',
    getSignatureFromTransaction(transaction),
);

    console.log("Sending and confirming transaction");
    await sendAndConfirmTransaction(transaction, { commitment: 'confirmed', maxRetries: 10, skipPreflight: true});
    console.log('Transfer confirmed: ', getSignatureFromTransaction(transaction));

    return;


   let connection = createSolanaRpc(mainnet('https://api.mainnet-beta.solana.com'));

    tx.result.transaction
    
}

function addSignature(transaction, signerPubKey, signatureBytes) {
    console.log(transaction.signatures);
    if (signerPubKey in transaction.signatures) {
        // const signatureBytes = getBase16Codec().encode(signatureHex);
        // Currently there's no public interface for adding a signature manually
        transaction = Object.freeze({
            ...transaction,
            signatures: Object.freeze({
                ...transaction.signatures,
                [signerPubKey]: signatureBytes,
            }),
        });
    }
    return transaction;
}

// async function createTransactionShimCommon(transaction: Transaction) {
//     const { getBase16Codec, getTransactionEncoder } = await loadSolanaLib();

//     return {

//         serializeMessage() {
//             return getBase16Codec().decode(transaction.messageBytes);
//         },
//         serialize() {
//             return pipe(transaction, getTransactionEncoder().encode, getBase16Codec().decode);
//         },
//     };
// }

// Call start
start();
